---
layout: syllabus
discipline: CSci
course_number: 1302
title: "Foundations of Computer Science"
credits: 4
semester: Spring
year: 2016
room: Sci 2190
times: MWF 9:15-10:20am
catalog_description: 	Basic proof techniques, propositional and predicate logic, induction and invariants, program correctness proofs, simple Big-Oh analysis of algorithms, set theory, introductory graph theory, and basic summations.
faculty: Nic McPhee
course_management_url: https://classroom.google.com/c/NDM0NDk0NTAx
---

Welcome to <em>{{ page.title }}</em> ({{ page.discipline}} {{ page.course_number}}).
This is a {{ page.credits }} credit course which meets on {{ page.times }} in {{ page.room }}.
There are no pre-requisites for this course, although parts of it will be a better
motivated if you've had at least a _little_ experience with programming, and it's
_crucial_ that you feel fairly comfortable with basic algebra and symbol manipulation.
This is primarily a "pencil and paper" course
introducing a number of important foundational theoretical concepts in computing. There
will be a *lot* of proofs. :-)

# Course description

The catalog description:

> {{ page.catalog_description }}

This is a very important, but often very challenging course, providing an introduction to discrete mathematics and other tools necessary to more formally understanding the meaning, correctness, and performance of algorithms. In practice most of the course will focus on ways of mathematically formalizing concepts that are crucial in computing, with special emphasis on logic and proofs. In key ways, this is the material that is crucial for moving from computing (and especially programming) as a _craft_ to computing as a _science_.

Most of you will have come from an intro programming course like CSci 1301 or be concurrently taking an intro programming course like CSci 1201, and this will be totally different from those. While those courses are largely about our interactions with computers, this course is about our interactions with the mathematics that underpins computing. As a result it will be a very conceptual course, and almost entirely pen and paper rather than "on the computer".

# Course goals and learning objectives

Key goals for this course include:

- An ability to translate between natural language statements and formal logical expressions and back again.
- Experience with a variety of proof styles.
- An understanding of the rules of propositional logic.
- An ability to transform and simplify propositional expressions.
- An ability to transform and simplify logical tests in computer programs.
- An understanding of the rules of quantification and predicate logic.
- An ability to transform and simplify quantifiers and predicate logic expressions.
- An ability to transform and simplify quantified expressions in computer programs.
- An understanding of the basic concepts of algorithm efficiency (big-oh).
- An understanding of the basic rules of sets, and the relationship between set theory and logic.
- Experience with mathematical induction and applications to programs on recursive structures like lists.
- Experience in proving the correctness of simple imperative programs, including the use of loop invariants.
- An introduction to basic set theory.
- An introduction to the concept of graphs, and applications to computing.
- Experience applying these ideas in practical contexts where, for example, correctness or runtime performance are not obvious.

# Texts and other materials

This course has one required text: <cite>A logical approach to discrete math</cite> by David Gries and Fred Schneider, Spring, [ISBN 978-1441928351](http://www.bookfinder.com/search/?st=sr;ac=qr;isbn=978-1441928351).

I _really_ like this book, and have found it a valuable resource for many years.
it's not a "standard" book of this sort, but I think Gries & Schneider bring a
clarity and focus to this material that is quite wonderful. If you can really
absorb this material, you'll tend to find most other math wooly and wordy by
comparison.

# Course outline

See the [course schedule](../schedule) for the calendar and outline of the course.

My plan is to use much of the class time for Q&A, examples, and group work; I do not intend to repeat the bulk of the book in lecture. **This means that you need to read the book carefully, slowly, and in advance.** The book is dense and complex, however, so that's not always going to be easy. I strongly recommend that you start early, do examples, and note down questions as they come up! As well as traditional office hours, the TAs and I will also have various evening sessions where we'll be available to help work through examples and questions. Please do ask questions if you are ever confused or need a hand.

Like most education, this is a course where what you get out of it will depend a _great_ deal on how much you put into it. If you just do the minimal work, at the last minute, then you might get by, but that's probably all you'll do. To really "get" what's going on here, you should be aggressive and do as many of the problems in the book as makes sense, and the more confused or uncomfortable you are the _more_ problems you should be doing, as that's the only way you'll really improve things. You never know â€“ you might get lucky and have me use a problem on an exam that you've already done! You might consider getting a 3-ring binder or similar to keep track of your work, starting each new theorem on a new sheet. That way you can keep related material together, like multiple proofs of the same theorem that you or we come up with at different times during the semester.

# Course work and grading

We will have a combination of what-do-you-knows (WDYKs, ungraded "quizzes" just to see where everyone is), problem sets (combination of "math" problems and at least a few "programming" problems), two exams (probably in-class), and a final (also probably in-class). The course points will be distributed as:

- Problem sets: 40%
- WDYKs: 10%
- Exams: 15% each, so 30% total
- Final: 20%

The first mid-term exam will be on Friday, 26 Feb. The second will be on Friday, 15 Apr. The final will be during the scheduled finals period, 1:30-3:30pm, Monday, 9 May 2014.

The **what-do-you-knows** (**WDYKs**) are ungraded "quizzes" to see how everyone's doing. You will get points for being present and making an effort, but your effort doesn't need to be correct to get the points. It's OK to simply say "Not a clue", but it would be better to at least take a stab at the problem so we can get a better sense of where people are. You get one "free" missed WDYK during the semester.

On homeworks you're are allowed, and even encouraged, to work in groups as long as each person turns in their own work. It's obviously crucial that you understand whatever solutions are arrived at by the group so that you can be successful on things like exams.

**You may use up to five grace days** however you would like throughout the term. This means you may turn in one assignment five "school days" late, or five assignments one "school day" late, or some other combination, with no penalty. Here a "school day" is a day that classes, though not necessarily this one, meet on campus - e.g. no weekends or holidays will count against you. Late work, however, might not be graded until the end of the semester. If you wish to use grace days on an assignment you must explicitly indicate that on the assignment.

**Work on the exams needs to be independent**, and any sort of borrowing, collaboration, or plagiarism can lead to significant penalties, including a zero on the exam or an F in the course.

The primary factors used in grading will be correctness, completeness, and clarity.

Grades will be entered on [the course Google Classroom site]({{ page.course_management_url }}) and can be checked there throughout the semester. If you have any questions or concerns, please bring them up right away when it's much easier to address them.
